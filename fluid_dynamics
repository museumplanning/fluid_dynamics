let points = [];
let cols = 6;
let rows = 6;
let depths = 6;
let spacing = 150;
let cubeSize = spacing * (cols - 1);

let viscositySlider, turbulenceSlider, flowXSlider, speedSlider;

let viscosity = 0.92;
let turbulenceStrength = 0.05;
let flowBias;
let timeSpeed = 0.01;

let obstacles = [];

function setup() {
  createCanvas(1100, 650, WEBGL);
  flowBias = createVector(0.03, 0.01, 0);

  createP("Viscosity (fluid thickness)").position(10, height + 10);
  viscositySlider = createSlider(0.7, 0.995, viscosity, 0.005).position(10, height + 40);

  createP("Turbulence (chaotic motion)").position(10, height + 70);
  turbulenceSlider = createSlider(0, 0.5, turbulenceStrength, 0.01).position(10, height + 100);

  createP("Flow (X direction)").position(10, height + 130);
  flowXSlider = createSlider(-0.5, 0.5, flowBias.x, 0.01).position(10, height + 160);

  createP("Speed (simulation rate)").position(10, height + 190);
  speedSlider = createSlider(0.001, 0.2, timeSpeed, 0.001).position(10, height + 220);

  for (let z = 0; z < depths; z++) {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let baseX = -cubeSize / 2 + x * spacing;
        let baseY = -cubeSize / 2 + y * spacing;
        let baseZ = -cubeSize / 2 + z * spacing;

        points.push({
          base: createVector(baseX, baseY, baseZ),
          pos: createVector(baseX, baseY, baseZ),
          vel: createVector(0, 0, 0),
          prev: createVector(baseX, baseY, baseZ)
        });
      }
    }
  }

  obstacles.push({
    pos: createVector(0, 0, 0),
    radius: 80
  });
}

function draw() {
  background(255);
  orbitControl();
  rotateX(-0.3);
  rotateY(frameCount * 0.002);

  viscosity = viscositySlider.value();
  turbulenceStrength = turbulenceSlider.value();
  flowBias.x = flowXSlider.value();
  timeSpeed = speedSlider.value();

  let t = frameCount * timeSpeed;

  for (let pt of points) {
    pt.prev.set(pt.pos);

    let turb = createVector(
      map(noise(pt.base.y * 0.01, pt.base.z * 0.01, t), 0, 1, -1, 1),
      map(noise(pt.base.z * 0.01, pt.base.x * 0.01, t + 100), 0, 1, -1, 1),
      map(noise(pt.base.x * 0.01, pt.base.y * 0.01, t + 200), 0, 1, -1, 1)
    ).mult(turbulenceStrength);

    let influence = createVector(0, 0, 0);
    for (let neighbor of points) {
      let d = p5.Vector.dist(pt.base, neighbor.base);
      if (d > 0 && d < spacing * 1.5) {
        let delta = p5.Vector.sub(neighbor.pos, pt.pos);
        delta.mult(0.002 / d);
        influence.add(delta);
      }
    }

    pt.vel.add(turb);
    pt.vel.add(flowBias);
    pt.vel.add(influence);
    pt.vel.mult(viscosity);
    pt.pos.add(pt.vel);

    for (let obs of obstacles) {
      let toObstacle = p5.Vector.sub(pt.pos, obs.pos);
      let d = toObstacle.mag();
      if (d < obs.radius) {
        let surfaceNormal = toObstacle.copy().normalize();
        pt.pos = obs.pos.copy().add(surfaceNormal.mult(obs.radius));
        pt.vel.reflect(surfaceNormal);
        pt.vel.mult(0.5); // optional damping
      }
    }

    pt.pos.x = constrain(pt.pos.x, pt.base.x - spacing / 2 + 10, pt.base.x + spacing / 2 - 10);
    pt.pos.y = constrain(pt.pos.y, pt.base.y - spacing / 2 + 10, pt.base.y + spacing / 2 - 10);
    pt.pos.z = constrain(pt.pos.z, pt.base.z - spacing / 2 + 10, pt.base.z + spacing / 2 - 10);

    push();
    stroke(0, 255, 255);
    line(pt.pos.x, pt.pos.y, pt.pos.z,
         pt.pos.x + pt.vel.x * 20,
         pt.pos.y + pt.vel.y * 20,
         pt.pos.z + pt.vel.z * 20);
    pop();

    push();
    stroke(0, 100, 255, 80);
    line(pt.prev.x, pt.prev.y, pt.prev.z, pt.pos.x, pt.pos.y, pt.pos.z);
    pop();

    push();
    translate(pt.pos.x, pt.pos.y, pt.pos.z);
    noStroke();
    fill(0, 200, 255);
    sphere(5);
    pop();
  }

  for (let obs of obstacles) {
    push();
    translate(obs.pos.x, obs.pos.y, obs.pos.z);
    noFill();
    stroke(255, 0, 0);
    sphere(obs.radius);
    pop();
  }
}
